"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Contract = void 0;

var _ethereumjsAbi = _interopRequireDefault(require("ethereumjs-abi"));

var _method = require("../action/method");

var _address = require("../crypto/address");

var _abiToByte = require("./abi-to-byte");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Contract {
  // The json interface for the contract to instantiate
  // This address is necessary for executions and call requests
  // The options of the contract.
  setProvider(provider) {
    this.provider = provider;
  }

  constructor( // tslint:disable-next-line: no-any
  jsonInterface, address, options) {
    _defineProperty(this, "abi", void 0);

    _defineProperty(this, "address", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "provider", void 0);

    _defineProperty(this, "methods", void 0);

    _defineProperty(this, "decodeMethods", void 0);

    this.provider = options && options.provider;

    if (jsonInterface) {
      this.abi = (0, _abiToByte.getAbiFunctions)(jsonInterface);
      const methods = {}; // @ts-ignore

      for (const fnName of Object.keys(this.abi)) {
        // @ts-ignore
        const fnAbi = this.abi[fnName];

        if (fnAbi.type === "constructor") {
          continue;
        }

        const args = (0, _abiToByte.getArgTypes)(fnAbi);
        const header = (0, _abiToByte.getHeaderHash)(fnAbi, args); // @ts-ignore

        methods[header] = {
          name: fnName,
          inputsNames: args.map(i => {
            return `${i.name}`;
          }),
          inputsTypes: args.map(i => {
            return `${i.type}`;
          })
        };
      }

      this.decodeMethods = methods;
    }

    this.address = address;
    this.options = options; // mount methods

    this.methods = {}; // tslint:disable-next-line: no-for-in

    for (const func in this.abi) {
      if (!this.abi.hasOwnProperty(func)) {
        // eslint-disable-next-line no-continue
        continue;
      }

      this.methods[func] = async (...args) => {
        if (!this.address || !this.abi) {
          throw new Error("must set contract address and abi");
        }

        if (args.length < 1) {
          throw new Error("must set method execute parameter");
        }

        if (!this.provider) {
          throw new Error("no rpc method provider specified");
        }

        const executeParameter = args[args.length - 1];
        const abiFunc = this.abi[func];
        const userInput = {};

        if (!abiFunc.inputs || !Array.isArray(abiFunc.inputs)) {
          return userInput;
        } // tslint:disable-next-line: no-any


        abiFunc.inputs.map((val, i) => {
          // @ts-ignore
          userInput[val.name] = args[i];
        });

        if (abiFunc.stateMutability === "view") {
          const result = await this.provider.readContract({
            execution: this.pureEncodeMethod("0", func, ...args.slice(0, args.length - 1)),
            callerAddress: this.address
          });
          return this.decodeMethodResult(func, result.data);
        }

        const methodEnvelop = this.encodeMethod(executeParameter.amount || "0", func, userInput, executeParameter.gasLimit, executeParameter.gasPrice);
        const method = new _method.ExecutionMethod(this.provider, executeParameter.account, methodEnvelop, {
          signer: this.options && this.options.signer
        });
        return method.execute();
      };
    }
  } // tslint:disable-next-line: no-any


  getABI() {
    return this.abi;
  }

  getAddress() {
    return this.address;
  }

  async deploy(account, // tslint:disable-next-line: no-any
  inputs, amount, gasLimit, gasPrice) {
    if (!this.options) {
      throw new Error("must set contract byte code");
    }

    if (!this.provider) {
      throw new Error("no rpc method provider specified");
    }

    let data = this.options.data || Buffer.from([]);

    if (this.abi && this.abi.hasOwnProperty(_abiToByte.Constructor)) {
      const abiFunc = this.abi[_abiToByte.Constructor];
      const userInput = {}; // @ts-ignore

      if (!abiFunc.inputs || !Array.isArray(abiFunc.inputs)) {
        throw new Error("construtor input error");
      } // @ts-ignore
      // tslint:disable-next-line: no-any


      abiFunc.inputs.map((val, i) => {
        // @ts-ignore
        userInput[val.name] = inputs[i];
      });
      data = Buffer.concat([data, // @ts-ignore
      Buffer.from((0, _abiToByte.encodeArguments)((0, _abiToByte.getArgTypes)(abiFunc), userInput), "hex")]);
    }

    const contractEnvelop = {
      gasLimit: gasLimit,
      gasPrice: gasPrice,
      contract: "",
      amount: amount || "0",
      data: data
    };
    return new _method.ExecutionMethod(this.provider, account, contractEnvelop, {
      signer: this.options && this.options.signer
    }).execute();
  }

  pureEncodeMethod(amount, method, ...args) {
    if (!this.address || !this.abi) {
      throw new Error("must set contract address and abi");
    }

    if (!this.abi[method]) {
      throw new Error(`method ${method} does not in abi`);
    }

    const abiFunc = this.abi[method];
    const userInput = {}; // tslint:disable-next-line: no-any

    abiFunc.inputs.map((val, i) => {
      let name = val.name;

      if (name === "") {
        name = `arg${i}`;
      } // @ts-ignore


      userInput[name] = args[i];
    });
    return this.encodeMethod(amount, method, userInput);
  }

  encodeMethod(amount, method, // tslint:disable-next-line:no-any
  input, gasLimit, gasPrice) {
    if (!this.address || !this.abi) {
      throw new Error("must set contract address and abi");
    }

    if (!this.abi[method]) {
      throw new Error(`method ${method} does not in abi`);
    }

    return {
      gasLimit: gasLimit,
      gasPrice: gasPrice,
      contract: this.address,
      amount: amount,
      data: Buffer.from((0, _abiToByte.encodeInputData)(this.abi, method, input), "hex")
    };
  }

  decodeMethodResult(method, result) {
    const outTypes = []; // @ts-ignore

    this.getABI()[method].outputs.forEach(field => {
      outTypes.push(field.type);
    });

    if (outTypes.length === 0) {
      return null;
    }

    const results = _ethereumjsAbi.default.rawDecode(outTypes, Buffer.from(result, "hex"));

    for (let i = 0; i < outTypes.length; i++) {
      if (outTypes[i] === "address") {
        results[i] = (0, _address.fromBytes)(Buffer.from(results[i].toString(), "hex")).string();
      }

      if (outTypes[i] === "address[]") {
        for (let j = 0; j < results[i].length; j++) {
          results[i][j] = (0, _address.fromBytes)(Buffer.from(results[i][j].toString(), "hex")).string();
        }
      }
    }

    if (outTypes.length === 1) {
      return results[0];
    }

    return results;
  }

  decodeInput(data) {
    if (data.length < 8) {
      throw new Error("input data error");
    }

    const methodKey = data.substr(0, 8);
    const method = this.decodeMethods[methodKey];

    if (!method) {
      throw new Error(`method ${methodKey} is not contract method`);
    }

    const params = _ethereumjsAbi.default.rawDecode(method.inputsTypes, Buffer.from(data.substring(8), "hex"));

    const values = {};

    for (let i = 0; i < method.inputsTypes.length; i++) {
      if (method.inputsTypes[i] === "address") {
        params[i] = (0, _address.fromBytes)(Buffer.from(params[i].toString(), "hex")).string();
      } // @ts-ignore


      values[method.inputsNames[i]] = params[i];
    }

    return {
      method: method.name,
      data: values
    };
  }

}

exports.Contract = Contract;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb250cmFjdC9jb250cmFjdC50cyJdLCJuYW1lcyI6WyJDb250cmFjdCIsInNldFByb3ZpZGVyIiwicHJvdmlkZXIiLCJjb25zdHJ1Y3RvciIsImpzb25JbnRlcmZhY2UiLCJhZGRyZXNzIiwib3B0aW9ucyIsImFiaSIsIm1ldGhvZHMiLCJmbk5hbWUiLCJPYmplY3QiLCJrZXlzIiwiZm5BYmkiLCJ0eXBlIiwiYXJncyIsImhlYWRlciIsIm5hbWUiLCJpbnB1dHNOYW1lcyIsIm1hcCIsImkiLCJpbnB1dHNUeXBlcyIsImRlY29kZU1ldGhvZHMiLCJmdW5jIiwiaGFzT3duUHJvcGVydHkiLCJFcnJvciIsImxlbmd0aCIsImV4ZWN1dGVQYXJhbWV0ZXIiLCJhYmlGdW5jIiwidXNlcklucHV0IiwiaW5wdXRzIiwiQXJyYXkiLCJpc0FycmF5IiwidmFsIiwic3RhdGVNdXRhYmlsaXR5IiwicmVzdWx0IiwicmVhZENvbnRyYWN0IiwiZXhlY3V0aW9uIiwicHVyZUVuY29kZU1ldGhvZCIsInNsaWNlIiwiY2FsbGVyQWRkcmVzcyIsImRlY29kZU1ldGhvZFJlc3VsdCIsImRhdGEiLCJtZXRob2RFbnZlbG9wIiwiZW5jb2RlTWV0aG9kIiwiYW1vdW50IiwiZ2FzTGltaXQiLCJnYXNQcmljZSIsIm1ldGhvZCIsIkV4ZWN1dGlvbk1ldGhvZCIsImFjY291bnQiLCJzaWduZXIiLCJleGVjdXRlIiwiZ2V0QUJJIiwiZ2V0QWRkcmVzcyIsImRlcGxveSIsIkJ1ZmZlciIsImZyb20iLCJDb25zdHJ1Y3RvciIsImNvbmNhdCIsImNvbnRyYWN0RW52ZWxvcCIsImNvbnRyYWN0IiwiaW5wdXQiLCJvdXRUeXBlcyIsIm91dHB1dHMiLCJmb3JFYWNoIiwiZmllbGQiLCJwdXNoIiwicmVzdWx0cyIsImV0aGVyZXVtanMiLCJyYXdEZWNvZGUiLCJ0b1N0cmluZyIsInN0cmluZyIsImoiLCJkZWNvZGVJbnB1dCIsIm1ldGhvZEtleSIsInN1YnN0ciIsInBhcmFtcyIs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QUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNEIsTUFBTSxDQUFDM0IsV0FBUCxDQUFtQkssTUFBdkMsRUFBK0NOLENBQUMsRUFBaEQsRUFBb0Q7QUFDbEQsVUFBSTRCLE1BQU0sQ0FBQzNCLFdBQVAsQ0FBbUJELENBQW5CLE1BQTBCLFNBQTlCLEVBQXlDO0FBQ3ZDeUQsUUFBQUEsTUFBTSxDQUFDekQsQ0FBRCxDQUFOLEdBQVksd0JBQ1ZvQyxNQUFNLENBQUNDLElBQVAsQ0FBWW9CLE1BQU0sQ0FBQ3pELENBQUQsQ0FBTixDQUFVbUQsUUFBVixFQUFaLEVBQWtDLEtBQWxDLENBRFUsRUFFVkMsTUFGVSxFQUFaO0FBR0QsT0FMaUQsQ0FNbEQ7OztBQUNBTyxNQUFBQSxNQUFNLENBQUMvQixNQUFNLENBQUM5QixXQUFQLENBQW1CRSxDQUFuQixDQUFELENBQU4sR0FBZ0N5RCxNQUFNLENBQUN6RCxDQUFELENBQXRDO0FBQ0Q7O0FBRUQsV0FBTztBQUNMNEIsTUFBQUEsTUFBTSxFQUFFQSxNQUFNLENBQUMvQixJQURWO0FBRUx5QixNQUFBQSxJQUFJLEVBQUVxQztBQUZELEtBQVA7QUFJRDs7QUFuU21CIiwic291cmNlc0NvbnRlbnQiOlsiLyogdHNsaW50OmRpc2FibGU6bm8tYW55ICovXG5pbXBvcnQgZXRoZXJldW1qcyBmcm9tIFwiZXRoZXJldW1qcy1hYmlcIjtcbmltcG9ydCB7IElBY2NvdW50IH0gZnJvbSBcIi4uL2FjY291bnQvYWNjb3VudFwiO1xuaW1wb3J0IHsgRXhlY3V0aW9uTWV0aG9kLCBTaWduZXJQbHVnaW4gfSBmcm9tIFwiLi4vYWN0aW9uL21ldGhvZFwiO1xuaW1wb3J0IHsgRXhlY3V0aW9uIH0gZnJvbSBcIi4uL2FjdGlvbi90eXBlc1wiO1xuaW1wb3J0IHsgZnJvbUJ5dGVzIH0gZnJvbSBcIi4uL2NyeXB0by9hZGRyZXNzXCI7XG5pbXBvcnQgeyBJUnBjTWV0aG9kIH0gZnJvbSBcIi4uL3JwYy1tZXRob2QvdHlwZXNcIjtcbmltcG9ydCB7IEFCSURlZmluaXRpb24gfSBmcm9tIFwiLi9hYmlcIjtcbmltcG9ydCB7XG4gIEFiaUJ5RnVuYyxcbiAgQ29uc3RydWN0b3IsXG4gIGVuY29kZUFyZ3VtZW50cyxcbiAgZW5jb2RlSW5wdXREYXRhLFxuICBnZXRBYmlGdW5jdGlvbnMsXG4gIGdldEFyZ1R5cGVzLFxuICBnZXRIZWFkZXJIYXNoXG59IGZyb20gXCIuL2FiaS10by1ieXRlXCI7XG5cbmV4cG9ydCB0eXBlIE9wdGlvbnMgPSB7XG4gIC8vIFRoZSBieXRlIGNvZGUgb2YgdGhlIGNvbnRyYWN0LiBVc2VkIHdoZW4gdGhlIGNvbnRyYWN0IGdldHMgZGVwbG95ZWRcbiAgZGF0YT86IEJ1ZmZlcjtcbiAgcHJvdmlkZXI/OiBJUnBjTWV0aG9kO1xuICBzaWduZXI/OiBTaWduZXJQbHVnaW47XG59O1xuXG5leHBvcnQgY2xhc3MgQ29udHJhY3Qge1xuICAvLyBUaGUganNvbiBpbnRlcmZhY2UgZm9yIHRoZSBjb250cmFjdCB0byBpbnN0YW50aWF0ZVxuICBwcml2YXRlIHJlYWRvbmx5IGFiaT86IEFiaUJ5RnVuYztcblxuICAvLyBUaGlzIGFkZHJlc3MgaXMgbmVjZXNzYXJ5IGZvciBleGVjdXRpb25zIGFuZCBjYWxsIHJlcXVlc3RzXG4gIHByaXZhdGUgcmVhZG9ubHkgYWRkcmVzcz86IHN0cmluZztcblxuICAvLyBUaGUgb3B0aW9ucyBvZiB0aGUgY29udHJhY3QuXG4gIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9ucz86IE9wdGlvbnM7XG5cbiAgcHVibGljIHByb3ZpZGVyPzogSVJwY01ldGhvZDtcblxuICBwdWJsaWMgcmVhZG9ubHkgbWV0aG9kczogeyBbZnVuY05hbWU6IHN0cmluZ106IEZ1bmN0aW9uIH07XG5cbiAgcHVibGljIHJlYWRvbmx5IGRlY29kZU1ldGhvZHM6IHsgW2tleTogc3RyaW5nXTogRGVjb2RlTWV0aG9kIH07XG5cbiAgcHVibGljIHNldFByb3ZpZGVyKHByb3ZpZGVyOiBJUnBjTWV0aG9kKTogdm9pZCB7XG4gICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1hbnlcbiAgICBqc29uSW50ZXJmYWNlPzogQXJyYXk8QUJJRGVmaW5pdGlvbj4sXG4gICAgYWRkcmVzcz86IHN0cmluZyxcbiAgICBvcHRpb25zPzogT3B0aW9uc1xuICApIHtcbiAgICB0aGlzLnByb3ZpZGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLnByb3ZpZGVyO1xuICAgIGlmIChqc29uSW50ZXJmYWNlKSB7XG4gICAgICB0aGlzLmFiaSA9IGdldEFiaUZ1bmN0aW9ucyhqc29uSW50ZXJmYWNlKTtcbiAgICAgIGNvbnN0IG1ldGhvZHMgPSB7fTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGZvciAoY29uc3QgZm5OYW1lIG9mIE9iamVjdC5rZXlzKHRoaXMuYWJpKSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IGZuQWJpID0gdGhpcy5hYmlbZm5OYW1lXTtcbiAgICAgICAgaWYgKGZuQWJpLnR5cGUgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXJncyA9IGdldEFyZ1R5cGVzKGZuQWJpKTtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gZ2V0SGVhZGVySGFzaChmbkFiaSwgYXJncyk7XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBtZXRob2RzW2hlYWRlcl0gPSB7XG4gICAgICAgICAgbmFtZTogZm5OYW1lLFxuICAgICAgICAgIGlucHV0c05hbWVzOiBhcmdzLm1hcChpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBgJHtpLm5hbWV9YDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBpbnB1dHNUeXBlczogYXJncy5tYXAoaSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYCR7aS50eXBlfWA7XG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVjb2RlTWV0aG9kcyA9IG1ldGhvZHM7XG4gICAgfVxuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIC8vIG1vdW50IG1ldGhvZHNcbiAgICB0aGlzLm1ldGhvZHMgPSB7fTtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWZvci1pblxuICAgIGZvciAoY29uc3QgZnVuYyBpbiB0aGlzLmFiaSkge1xuICAgICAgaWYgKCF0aGlzLmFiaS5oYXNPd25Qcm9wZXJ0eShmdW5jKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWV0aG9kc1tmdW5jXSA9IGFzeW5jICguLi5hcmdzOiBBcnJheTxhbnk+KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5hZGRyZXNzIHx8ICF0aGlzLmFiaSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm11c3Qgc2V0IGNvbnRyYWN0IGFkZHJlc3MgYW5kIGFiaVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibXVzdCBzZXQgbWV0aG9kIGV4ZWN1dGUgcGFyYW1ldGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHJwYyBtZXRob2QgcHJvdmlkZXIgc3BlY2lmaWVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4ZWN1dGVQYXJhbWV0ZXI6IE1ldGhvZEV4ZWN1dGVQYXJhbWV0ZXIgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IGFiaUZ1bmMgPSB0aGlzLmFiaVtmdW5jXTtcbiAgICAgICAgY29uc3QgdXNlcklucHV0ID0ge307XG4gICAgICAgIGlmICghYWJpRnVuYy5pbnB1dHMgfHwgIUFycmF5LmlzQXJyYXkoYWJpRnVuYy5pbnB1dHMpKSB7XG4gICAgICAgICAgcmV0dXJuIHVzZXJJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWFueVxuICAgICAgICBhYmlGdW5jLmlucHV0cy5tYXAoKHZhbDogYW55LCBpOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgdXNlcklucHV0W3ZhbC5uYW1lXSA9IGFyZ3NbaV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChhYmlGdW5jLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICBleGVjdXRpb246IHRoaXMucHVyZUVuY29kZU1ldGhvZChcbiAgICAgICAgICAgICAgXCIwXCIsXG4gICAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgICAgIC4uLmFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNhbGxlckFkZHJlc3M6IHRoaXMuYWRkcmVzc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZU1ldGhvZFJlc3VsdChmdW5jLCByZXN1bHQuZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtZXRob2RFbnZlbG9wID0gdGhpcy5lbmNvZGVNZXRob2QoXG4gICAgICAgICAgZXhlY3V0ZVBhcmFtZXRlci5hbW91bnQgfHwgXCIwXCIsXG4gICAgICAgICAgZnVuYyxcbiAgICAgICAgICB1c2VySW5wdXQsXG4gICAgICAgICAgZXhlY3V0ZVBhcmFtZXRlci5nYXNMaW1pdCxcbiAgICAgICAgICBleGVjdXRlUGFyYW1ldGVyLmdhc1ByaWNlXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IG5ldyBFeGVjdXRpb25NZXRob2QoXG4gICAgICAgICAgdGhpcy5wcm92aWRlcixcbiAgICAgICAgICBleGVjdXRlUGFyYW1ldGVyLmFjY291bnQsXG4gICAgICAgICAgbWV0aG9kRW52ZWxvcCxcbiAgICAgICAgICB7IHNpZ25lcjogdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5zaWduZXIgfVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBtZXRob2QuZXhlY3V0ZSgpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWFueVxuICBwdWJsaWMgZ2V0QUJJKCk6IEFiaUJ5RnVuYyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuYWJpO1xuICB9XG5cbiAgcHVibGljIGdldEFkZHJlc3MoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5hZGRyZXNzO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlcGxveShcbiAgICBhY2NvdW50OiBJQWNjb3VudCxcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWFueVxuICAgIGlucHV0czogQXJyYXk8YW55PixcbiAgICBhbW91bnQ/OiBzdHJpbmcsXG4gICAgZ2FzTGltaXQ/OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgZ2FzUHJpY2U/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibXVzdCBzZXQgY29udHJhY3QgYnl0ZSBjb2RlXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHJwYyBtZXRob2QgcHJvdmlkZXIgc3BlY2lmaWVkXCIpO1xuICAgIH1cblxuICAgIGxldCBkYXRhID0gdGhpcy5vcHRpb25zLmRhdGEgfHwgQnVmZmVyLmZyb20oW10pO1xuICAgIGlmICh0aGlzLmFiaSAmJiB0aGlzLmFiaS5oYXNPd25Qcm9wZXJ0eShDb25zdHJ1Y3RvcikpIHtcbiAgICAgIGNvbnN0IGFiaUZ1bmMgPSB0aGlzLmFiaVtDb25zdHJ1Y3Rvcl07XG4gICAgICBjb25zdCB1c2VySW5wdXQgPSB7fTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmICghYWJpRnVuYy5pbnB1dHMgfHwgIUFycmF5LmlzQXJyYXkoYWJpRnVuYy5pbnB1dHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnN0cnV0b3IgaW5wdXQgZXJyb3JcIik7XG4gICAgICB9XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWFueVxuICAgICAgYWJpRnVuYy5pbnB1dHMubWFwKCh2YWw6IGFueSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdXNlcklucHV0W3ZhbC5uYW1lXSA9IGlucHV0c1tpXTtcbiAgICAgIH0pO1xuICAgICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICBkYXRhLFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIEJ1ZmZlci5mcm9tKGVuY29kZUFyZ3VtZW50cyhnZXRBcmdUeXBlcyhhYmlGdW5jKSwgdXNlcklucHV0KSwgXCJoZXhcIilcbiAgICAgIF0pO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRyYWN0RW52ZWxvcCA9IHtcbiAgICAgIGdhc0xpbWl0OiBnYXNMaW1pdCxcbiAgICAgIGdhc1ByaWNlOiBnYXNQcmljZSxcbiAgICAgIGNvbnRyYWN0OiBcIlwiLFxuICAgICAgYW1vdW50OiBhbW91bnQgfHwgXCIwXCIsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IEV4ZWN1dGlvbk1ldGhvZCh0aGlzLnByb3ZpZGVyLCBhY2NvdW50LCBjb250cmFjdEVudmVsb3AsIHtcbiAgICAgIHNpZ25lcjogdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5zaWduZXJcbiAgICB9KS5leGVjdXRlKCk7XG4gIH1cblxuICBwdWJsaWMgcHVyZUVuY29kZU1ldGhvZChcbiAgICBhbW91bnQ6IHN0cmluZyxcbiAgICBtZXRob2Q6IHN0cmluZyxcbiAgICAuLi5hcmdzOiBBcnJheTxhbnk+XG4gICk6IEV4ZWN1dGlvbiB7XG4gICAgaWYgKCF0aGlzLmFkZHJlc3MgfHwgIXRoaXMuYWJpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdXN0IHNldCBjb250cmFjdCBhZGRyZXNzIGFuZCBhYmlcIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5hYmlbbWV0aG9kXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBtZXRob2QgJHttZXRob2R9IGRvZXMgbm90IGluIGFiaWApO1xuICAgIH1cbiAgICBjb25zdCBhYmlGdW5jID0gdGhpcy5hYmlbbWV0aG9kXTtcblxuICAgIGNvbnN0IHVzZXJJbnB1dCA9IHt9O1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tYW55XG4gICAgYWJpRnVuYy5pbnB1dHMubWFwKCh2YWw6IGFueSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICBsZXQgbmFtZSA9IHZhbC5uYW1lO1xuICAgICAgaWYgKG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgbmFtZSA9IGBhcmcke2l9YDtcbiAgICAgIH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHVzZXJJbnB1dFtuYW1lXSA9IGFyZ3NbaV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5lbmNvZGVNZXRob2QoYW1vdW50LCBtZXRob2QsIHVzZXJJbnB1dCk7XG4gIH1cblxuICBwdWJsaWMgZW5jb2RlTWV0aG9kKFxuICAgIGFtb3VudDogc3RyaW5nLFxuICAgIG1ldGhvZDogc3RyaW5nLFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICBpbnB1dDogeyBba2V5OiBzdHJpbmddOiBhbnkgfSxcbiAgICBnYXNMaW1pdD86IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBnYXNQcmljZT86IHN0cmluZ1xuICApOiBFeGVjdXRpb24ge1xuICAgIGlmICghdGhpcy5hZGRyZXNzIHx8ICF0aGlzLmFiaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibXVzdCBzZXQgY29udHJhY3QgYWRkcmVzcyBhbmQgYWJpXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYWJpW21ldGhvZF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbWV0aG9kICR7bWV0aG9kfSBkb2VzIG5vdCBpbiBhYmlgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2FzTGltaXQ6IGdhc0xpbWl0LFxuICAgICAgZ2FzUHJpY2U6IGdhc1ByaWNlLFxuICAgICAgY29udHJhY3Q6IHRoaXMuYWRkcmVzcyxcbiAgICAgIGFtb3VudDogYW1vdW50LFxuICAgICAgZGF0YTogQnVmZmVyLmZyb20oZW5jb2RlSW5wdXREYXRhKHRoaXMuYWJpLCBtZXRob2QsIGlucHV0KSwgXCJoZXhcIilcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGRlY29kZU1ldGhvZFJlc3VsdChtZXRob2Q6IHN0cmluZywgcmVzdWx0OiBzdHJpbmcpOiBhbnkgfCBBcnJheTxhbnk+IHtcbiAgICBjb25zdCBvdXRUeXBlcyA9IFtdIGFzIEFycmF5PHN0cmluZz47XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5nZXRBQkkoKVttZXRob2RdLm91dHB1dHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICBvdXRUeXBlcy5wdXNoKGZpZWxkLnR5cGUpO1xuICAgIH0pO1xuXG4gICAgaWYgKG91dFR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0cyA9IGV0aGVyZXVtanMucmF3RGVjb2RlKG91dFR5cGVzLCBCdWZmZXIuZnJvbShyZXN1bHQsIFwiaGV4XCIpKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvdXRUeXBlc1tpXSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgcmVzdWx0c1tpXSA9IGZyb21CeXRlcyhcbiAgICAgICAgICBCdWZmZXIuZnJvbShyZXN1bHRzW2ldLnRvU3RyaW5nKCksIFwiaGV4XCIpXG4gICAgICAgICkuc3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAob3V0VHlwZXNbaV0gPT09IFwiYWRkcmVzc1tdXCIpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZXN1bHRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgcmVzdWx0c1tpXVtqXSA9IGZyb21CeXRlcyhcbiAgICAgICAgICAgIEJ1ZmZlci5mcm9tKHJlc3VsdHNbaV1bal0udG9TdHJpbmcoKSwgXCJoZXhcIilcbiAgICAgICAgICApLnN0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG91dFR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHJlc3VsdHNbMF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgcHVibGljIGRlY29kZUlucHV0KGRhdGE6IHN0cmluZyk6IERlY29kZURhdGEge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IDgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlucHV0IGRhdGEgZXJyb3JcIik7XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZEtleSA9IGRhdGEuc3Vic3RyKDAsIDgpO1xuICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMuZGVjb2RlTWV0aG9kc1ttZXRob2RLZXldO1xuICAgIGlmICghbWV0aG9kKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG1ldGhvZCAke21ldGhvZEtleX0gaXMgbm90IGNvbnRyYWN0IG1ldGhvZGApO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXMgPSBldGhlcmV1bWpzLnJhd0RlY29kZShcbiAgICAgIG1ldGhvZC5pbnB1dHNUeXBlcyxcbiAgICAgIEJ1ZmZlci5mcm9tKGRhdGEuc3Vic3RyaW5nKDgpLCBcImhleFwiKVxuICAgICk7XG4gICAgY29uc3QgdmFsdWVzID0ge307XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGhvZC5pbnB1dHNUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG1ldGhvZC5pbnB1dHNUeXBlc1tpXSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgcGFyYW1zW2ldID0gZnJvbUJ5dGVzKFxuICAgICAgICAgIEJ1ZmZlci5mcm9tKHBhcmFtc1tpXS50b1N0cmluZygpLCBcImhleFwiKVxuICAgICAgICApLnN0cmluZygpO1xuICAgICAgfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdmFsdWVzW21ldGhvZC5pbnB1dHNOYW1lc1tpXV0gPSBwYXJhbXNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLm5hbWUsXG4gICAgICBkYXRhOiB2YWx1ZXNcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWV0aG9kRXhlY3V0ZVBhcmFtZXRlciB7XG4gIGFjY291bnQ6IElBY2NvdW50O1xuICBhbW91bnQ/OiBzdHJpbmc7XG4gIGdhc0xpbWl0Pzogc3RyaW5nO1xuICBnYXNQcmljZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZWNvZGVEYXRhIHtcbiAgbWV0aG9kOiBzdHJpbmc7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tYW55XG4gIGRhdGE6IHsgW2tleTogc3RyaW5nXTogYW55IH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVjb2RlTWV0aG9kIHtcbiAgbmFtZTogc3RyaW5nO1xuICBpbnB1dHNOYW1lczogW3N0cmluZ107XG4gIGlucHV0c1R5cGVzOiBbc3RyaW5nXTtcbn1cbiJdfQ==